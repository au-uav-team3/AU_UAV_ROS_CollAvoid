/*
Implementation of force.h.  For comments on how to use these functions, visit force.h.  Comments in this file
are related to implementation, not usage.
*/

#include <math.h>
#include <stdlib.h>
#include <vector>
#include <algorithm>

#include "AU_UAV_ROS/force.h"
#include "AU_UAV_ROS/standardFuncs.h"		// for PI, EARTH_RADIUS, MPS_SPEED
#include "AU_UAV_ROS/SimulatedPlane.h"		// for MAXIMUM_TURNING_ANGLE
#define EPSILON 1e-4				// used to check floating point numbers for equality
#define LOOPING_DISTANCE 4*MPS_SPEED		// When distance to destination is less than this distance, we should start checking for looping
#define LOOP_RADIUS 28.64058013			// Turning radius of the UAV = MPS_SPEED/sin(MAXIMUM_TURNING_ANGLE)*sin((180-MAXIMUM_TURNING_ANGLE)/2)
						// Because the simulator assume straight turns, we used the law of sines to find the distance from the
						// points on the perimeter of the hexadecagon generated by a looping UAV to the center of hexadecagon

#define FIELD_TO_RADIUS_RATIO 5 		//Scalar that is multiplied with a plane's collision radius to get field size.
#define PLANE_CHARGE 80				//Amount of negative charge given to a plane.
#define DEST_CHARGE 100 			//Amount of positive charge given to a destination waypoint.
#define FIELD_ZONE 20 				//Determines how fast the repulsive force from a plane increases as one moves farther into its force field.
#define PRIORITY_DISTANCE 50 			//How close a plane must be to its destination to become considered for having priority (in meters).
#define FRONT_EMIT 1.5 				//The percent of calculated charge a plane will emit to repel a plane from its front.
#define BACK_EMIT 1.0 				//The percent of calculated charge a plane will emit to repel a plane approaching from behind.
#define FRONT_FEEL 1.0 				//The percent of calculated charge a plane will feel from the front (pushing plane "backwards")
#define	BACK_FEEL 0.5 				//The percent of calculated charge a plane will feel from the back (pushing plane "forwards")
#define	MAX_FRONT 2.0 				//Scalar that is multiplied with field size to adjust field in front of the plane
#define MAX_BACK 1.25 				//Scalar that is multiplied with field size to adjust field behind the plane
#define EXPAND_PRIORITY_FIELD 1.2 		//Scalar that increases the field size for planes that have priority

/*
The calculateForces method is the primary method in the force.cpp file.  Calling this
method will result in subsequent calls to all other methods in this file.  
*/
AU_UAV_ROS::mathVector AU_UAV_ROS::calculateForces(PlaneObject &pobj1, std::map<int, PlaneObject> &pobjects){
	double distance = 0.0, rAngle = 0.0, fieldAngle = 0.0, maxDistance = 0.0;
	mathVector rForce(0.0, 0.0), aForce(0.0, 0.0), tForce(1.0, 0.0), aForceUnit(0.0, 0.0), rForceUnit(0.0, 0.0);

	std::vector<PlaneObject> listPlanes;

	//copy the map into a vector so it can be sorted
	for (std::map<int, PlaneObject>::iterator iter = pobjects.begin(); iter != pobjects.end(); iter++)
		listPlanes.push_back(pobjects[iter->first]);
	
	//calculate the attraction force
	aForce = calculateAttractionForce(pobj1);

	//sort the planes based on distance to destination
	std::sort(listPlanes.begin(), listPlanes.end(), cmpDistToDest); 

	for(int i = 0; i < listPlanes.size(); i++){
		double distToDest = findDistance(listPlanes[i].getLatitude(), listPlanes[i].getLongitude(), 
							listPlanes[i].getDestination().latitude, listPlanes[i].getDestination().longitude);

		if(listPlanes[i].getID() == pobj1.getID() && distToDest < PRIORITY_DISTANCE){ 
			//This plane has priority over the rest so we don't need to calculate further forces.			
			break;
		}else if(listPlanes[i].getID() == pobj1.getID()){
			//these are the same plane...do nothing
		}else{
			//find angle between the bearing of listPlanes[i] and pobj1 
			fieldAngle = manipulateAngle(listPlanes[i].findAngle(pobj1) - listPlanes[i].getBearing());
				
			//find angle of repulsive force with respect to Cartesian coordinates
			rAngle = toCartesian(pobj1.findAngle(listPlanes[i]) - 180);

			// find distance between pobj1 and listPlanes[i]
			distance = pobj1.findDistance(listPlanes[i]);
			
			//Plane with priority must be treated with a larger field so as to be avoided
			if(distToDest < PRIORITY_DISTANCE){
				//Calculating size of expanded field at specified entry point, fieldAngle.
				maxDistance = FIELD_TO_RADIUS_RATIO * EXPAND_PRIORITY_FIELD * listPlanes[i].getCollisionRadius() * 
						((MAX_FRONT - ((MAX_FRONT - MAX_BACK)/2)) + ((MAX_FRONT - MAX_BACK)/2) * cos(fieldAngle * PI / 180));
			}else{
				//Calculating size of field at specified entry point, fieldAngle.
				maxDistance = FIELD_TO_RADIUS_RATIO * listPlanes[i].getCollisionRadius() * 
						((MAX_FRONT - ((MAX_FRONT - MAX_BACK)/2)) + ((MAX_FRONT - MAX_BACK)/2) * cos(fieldAngle * PI / 180));
			}

			//If a pobj1 is in the field of the other plane, new repulsion force is added to those previously calculated.
			if(distance <= maxDistance){
				rForce += calculateRepulsionForce(pobj1, distance, maxDistance, rAngle, fieldAngle, aForce.getDirection());
			}
		}
	}
	
	//Get unit vectors for forces
	aForceUnit = aForce;
	aForceUnit.setMagnitude(1);

	rForceUnit = rForce;
	if(rForceUnit.getMagnitude() > 0)
		rForceUnit.setMagnitude(1);

	//Use unit vectors to fix head on collisions
	if ((aForceUnit + rForceUnit).getMagnitude() < EPSILON){
		//give the planes a "nudge" to the right to break deadlock
		double newDirection = manipulateAngle(aForce.getDirection() - 15);

		tForce.setDirection(newDirection);
	}
	else{
		//calculate total force
		tForce = aForce + rForce;

		//Check to see if this total force will put plane in a loop
		if (inLoop(pobj1, tForce)){ 
			//pobj1 is in a loop, modify attractive force so that the destination is actually repulsive to break the cycle
			aForce.setDirection(manipulateAngle(aForce.getDirection() + 180));
			
			//we changed aForce so now need to recalculate tForce
			tForce = aForce + rForce;
		}
		
		//Make sure resulting force angle does not exceed turning angle of plane
		makeForceViable(pobj1, tForce);
	}
	return tForce;
}

/*
Calculates the repulsion force between two planes.
The distance parameter is the distance between the planes in meters, maxDistance is
the distance over which field pobj1 is in acts, rAngle is the angle of the repulsive force, 
fieldAngle is the angle between the bearing of the plane generating the force to the location
of pobj1, and aAngle is the angle between the bearing of pobj1 and the location of its destination.
All angles are in the Cartesian plane.
*/
AU_UAV_ROS::mathVector AU_UAV_ROS::calculateRepulsionForce(const PlaneObject &pobj1, double distance, 
							double maxDistance, double rAngle, double fieldAngle, double aAngle){
	double rForce = 0.0, rToBearing = 0.0;

	//If getting close to conflict zone, max repulsion.
	if(distance <= 2.5*MPS_SPEED){
		rForce = 99999;
	}else{
		//calculates the repulsive force emitted from other plane based on fieldAngle from which pobj1 is approaching
		rForce = PLANE_CHARGE * ((FRONT_EMIT-((FRONT_EMIT-BACK_EMIT)/2)) + ((FRONT_EMIT-BACK_EMIT)/2) * 
					cos(fieldAngle * PI / 180)) * (maxDistance - distance)/ (FIELD_ZONE);
	}

	//Calculates angle between pobj1's bearing and the direction of repulsion force.
	rToBearing = manipulateAngle(toCartesian(pobj1.getBearing()) - rAngle);
	
	
	//Determines if a plane should be forced to make a right turn to travel behind a plane approaching from the right.
	if(fieldAngle < 0 && fieldAngle > -135 && rToBearing < -90 && rToBearing > -180){
		double a = 0.0, b = 0.0, c = 0.0, A = 0.0, B = 0.0, C = 0.0;
			
		//Spherical law of cosines calculations
		if(fieldAngle > -25){
			a = distance / EARTH_RADIUS;
			B = -1 * fieldAngle * PI / 180;
			C = (180 - (-1 * rToBearing)) * PI / 180;

			A = acos(-cos(B)*cos(C) + sin(B)*sin(C)*cos(a));

			b = acos((cos(B) + cos(C)*cos(A))/(sin(C)*sin(A)));
			b *= EARTH_RADIUS;

			c = acos((cos(C) + cos(A)*cos(B))/(sin(A)*sin(B)));
			c *= EARTH_RADIUS;
		}

		//Angle between bearing and destination
		double aToBearing = manipulateAngle(toCartesian(pobj1.getBearing()) - aAngle);

		if((c - b) > ((-1 * rToBearing) - 90.0) && fieldAngle > -25){
			//Plane should not turn right, because I will turn into a plane
		}else if(aToBearing < 0 && fieldAngle < -90){
			//Plane should not turn right, parallel to other plane and my destination is to the left
		}else{
			//flip repulsive force across bearing to force right turn.
			rAngle = manipulateAngle(2 * (180 + rToBearing) + rAngle);
		}
	}	

	//calculates force felt by pobj1 based on angle, rToBearing, at which the force is applied.
	rForce = rForce * ((FRONT_FEEL-((FRONT_FEEL-BACK_FEEL)/2)) + (-0.5*(FRONT_FEEL-BACK_FEEL)) * cos(rToBearing * PI / 180));

	mathVector mV(rForce, rAngle);
	return mV;
}

/*
Calculates the direction the plane needs to head in order to reach destination
point, and sets the magnitude of this attractive force to the DEST_CHARGE.
*/
AU_UAV_ROS::mathVector AU_UAV_ROS::calculateAttractionForce(const PlaneObject &pobj1){
	double aForce = 0.0, aAngle = 0.0;
	
	//Find angle of attractive force and convert the angle from cardinal to cartesian
	aAngle = toCartesian(findAngle(pobj1.getLatitude(), pobj1.getLongitude(), 
					pobj1.getDestination().latitude, pobj1.getDestination().longitude));

	//Attractive force is constant (we want the plane to always be attracted by its destination)
	aForce = DEST_CHARGE;

	mathVector mV(aForce, aAngle);
	return mV;
}

/* 
Modifies the total force acting on pobj1 so that the new path does not differ more than 22.5 degrees from the current 
bearing.
*/
void AU_UAV_ROS::makeForceViable(PlaneObject &pobj1, mathVector &tForce){
	//angle of UAV bearing in degrees w/ respect to cartesian coordinates
	double UAVTheta = toCartesian(pobj1.getBearing());

	//Find angle between force vector and UAV
	double deltaTheta = tForce.getDirection() - UAVTheta;

	//Make sure angle is on interval [-180, 180]
	deltaTheta = manipulateAngle(deltaTheta);

	//Only allow turns of 22.5 degrees maximum
	if (deltaTheta > MAXIMUM_TURNING_ANGLE){
		deltaTheta = MAXIMUM_TURNING_ANGLE;
	}
	else if (deltaTheta < -MAXIMUM_TURNING_ANGLE){
		deltaTheta = -MAXIMUM_TURNING_ANGLE;
	}
	
	deltaTheta += UAVTheta;

	// Make sure angle is on interval [-180, 180]
	deltaTheta = manipulateAngle(deltaTheta);				

	tForce.setDirection(toCardinal(deltaTheta));
}

/* 
Method determines if aircraft is making a maximum angle turn and is within looping distance of its destination.
If so, it finds the distance between the destination of the UAV and the center of the circle made by a looping UAV,
and determines if the destination is unreachable.
*/
bool AU_UAV_ROS::inLoop(const PlaneObject &pobj1, mathVector &tForce){
	bool inLoop = false;
	//angle of actual UAV bearing in degrees w/ respect to cartesian coordinates
	double UAVTheta = toCartesian(pobj1.getActualBearing());
	double distanceToDest = findDistance(pobj1.getLatitude(), pobj1.getLongitude(), pobj1.getDestination().latitude, pobj1.getDestination().longitude);

	//Find angle between force vector and UAV
	double deltaTheta = tForce.getDirection() - UAVTheta;

	//Make sure angle is on interval [-180, 180]
	deltaTheta = manipulateAngle(deltaTheta);

	//Check to see if attempting a maximum turn
	if (deltaTheta > MAXIMUM_TURNING_ANGLE){
		//Check for looping
		if (distanceToDest < LOOPING_DISTANCE){
			// find distance between center of "circle" made when the UAV is looping and the destination
			double centerToWaypoint = findLoopDistance(pobj1,101.25);	

			//if the centerToWaypoint distance is less than LOOP_RADIUS-COLLISION_THRESHOLD, destination will not be reached
			if(centerToWaypoint < (LOOP_RADIUS-COLLISION_THRESHOLD)){
				inLoop = true;
			}else{
				inLoop = false;
			}
		}
	}
	
	//Check to see if attempting a maximum turn
 	 if(deltaTheta < -MAXIMUM_TURNING_ANGLE){
		//Check for looping
		if (distanceToDest < LOOPING_DISTANCE){
			// find distance between center of "circle" made when the UAV is looping and the destination
			double centerToWaypoint = findLoopDistance(pobj1,-101.25);

			//if the centerToWaypoint distance is less than LOOP_RADIUS-COLLISION_THRESHOLD, destination will not be reached
			if(centerToWaypoint < (LOOP_RADIUS-COLLISION_THRESHOLD)){
				inLoop = true;
			}else{
				inLoop = false;
			}
		}
	}
	return inLoop;
}

/*
Calculates the distance between the center of "circle" generated when a plane is looping around its destination
and the plane's destination.  The angle parameter is the number of degrees to the left or right of the UAV the center of
turning is located.  The angle parameter is based off of the turning angle per second.  Because the simulator
uses straight line paths between each of the waypoints given, a looping UAV actually creates a hexadecagon.  
For example, in this code 22.5 is our turning angle. Therefore, the angle provided for this method is either 101.25 or -101.25 since 
[(180-22.5)/2 = 78.75; 78.75 + 22.5 = 101.25].
*/
double AU_UAV_ROS::findLoopDistance(const PlaneObject &pobj1, double angle){
	//actual bearing of plane in cartesian coordinates
	double UAVTheta = toCartesian(pobj1.getActualBearing());
	//Angle from bearing of plane to center of turning radius circle in cardinal coordinates.
	double bearingToCenter = toCardinal(manipulateAngle(UAVTheta+angle));

	//angular distance to center of the "circle" generated by a looping UAV
	double distToCenter = LOOP_RADIUS/EARTH_RADIUS;

	//current position of plane
	AU_UAV_ROS::waypoint position;
	position.latitude = pobj1.getLatitude();
	position.longitude = pobj1.getLongitude();
	position.altitude = pobj1.getAltitude();

	//calculate location of the center of the "circle" generated by a looping UAV
	AU_UAV_ROS::waypoint centerPosition = calculateCoordinate(position, bearingToCenter, distToCenter);

	//distance between center and destination
	double centerToWaypoint = findDistance(centerPosition.latitude, centerPosition.longitude, 
					pobj1.getDestination().latitude, pobj1.getDestination().longitude);
	
	return centerToWaypoint;
}
